<!DOCTYPE html>
<html>


<head>
	<meta charset="utf-8"> 

<style>

body {
	background-color: #FFF278;
}


canvas { border: 1px solid black; }

</style>



</head>



<body>


<canvas id="objectFillIt" width="400" height="400"></canvas><br>
<button onclick="line1.drawLine()">draw line</button>

<button onclick="line1.eraseLine()">erase line</button>

<button onclick="wrapDraw()">draw lines</button>

<button onclick="wrapErase()">delete lines</button>

<script>

/*create a constructor for your line object
remember, a constructor is basically a function that can be used to create objects
and follows basically function syntax.

function namOfFunction(param1, param2) {
	statements here
}

you can have as many parameters as you wish. However, when calling a constructor to create your object, you must make sure
the values you pass are in the correct order of the params you intend for them to be used

to make the object constructor the most adaptable we are passing all variables as params. We are passing the canvas context 
we wish to use to ensure we don't run into scoping issues

*/


function lineObjectC(startX, startY, finishX, finishY, bgColor, lineColor, context) {
	this.startX = startX;
	this.startY = startY;
	this.finishX = finishX;
	this.finishY = finishY;
	this.bgColor = bgColor;
	this.lineColor = lineColor;
	this.context = context;
	this.drawLine = function() {
		this.context.beginPath();
		this.context.moveTo(this.startX, this.startY);
		this.context.lineTo(this.finishX, this.finishY);
		this.context.strokeStyle = lineColor;
		this.context.stroke();
	}
	this.eraseLine = function() {
		this.context.beginPath();
		this.context.moveTo(this.startX, this.startY);
		this.context.lineTo(this.finishX, this.finishY);
		this.context.strokeStyle = bgColor;
		this.context.stroke();
	}
}


//create our canvas and context
var lines=[]
var canvas = document.getElementById('objectFillIt');
var ctx = canvas.getContext('2d');


//create a single object. The functions get called in the buttons above
var line1 = new lineObjectC(10,0,10,400,"#FFF278", 'rgba(255, 83, 13, 1)', ctx);

/* While the code above allows us to create a single line and erase, we need an option to fill the canvas with lines to fully 
replicate our first Canvas project.

However, for scoping reasons, and to make our code more malleable (maybe we don't always want to first fill the canvas with lines, maybe we 
have a different pattern in mind), we will we split apart the creation of all of the lines, to the writing of the lines to the page.

*/

//globally declared variable that will be used hold our lines
var lines = [];

/*
let's create some line objects (but not write them to the page), and store them in an array.
We will pass the context just to be sure we don't run into scoping issues.
We will only pass the startX value, since we will use this for multiple values.
If we were fully optomizing, for reuse, we would not hard code any coordinates, color, and starts, etc. 
But for this project's design, which is very simple we don't need to abstract for that. I'm choosing to only abstract when needed.
*/


function createLines(lines, context, startX) {
	lines = lines;
	ctx = context;
	var startX = startX;
	var width = context.canvas.width;
	while (startX <= width) {
		lines[startX] = new lineObjectC(startX,0,startX,width,"#FFF278", 'rgba(255, 83, 13, 1)', ctx);
		startX = startX + 1;
	}
	return lines
}



/* The code for our first canvas used setInterval to called the draw() function to write a single line once a second, until reaching the full canvas width.
Since we already have the 
We will use setTimeout instead this time, to avoid a potential infinite loop.
In addition, since we must iterate through an array to draw/erase the lines, we need to manage the "timing". Javascript, similar to HTML, will read and perform each statement from top to bottom of the written code. However, it will also begin to perform the requested actions of the next statement, even if the previous statement is not yet complete. In our case, means our code will draw each line merely miliseconds apart, so our timing will not appear to be applied. For this reason we must create a function that calls the lines[x].drawLine(), and then call back to that same function, so the timing is honored.

I have also created a "wrapper" function for each so that our x and howManyTimes variables are scoped in the way we need them for each function.
*/

var width = lines.length;

function wrapDraw() {
	x = 0; howManyTimes = 400;
	drawLines(x);
}

function drawLines() {
	lines[x].drawLine();
    x++;
    if( x <= howManyTimes ){
        setTimeout(drawLines, 50);
    }
}

function wrapErase() {
	x = 0; howManyTimes = 400;
	eraseLines(x);
}

function eraseLines() {
	lines[x].eraseLine();
    x++;
    if( x <= howManyTimes ){
        setTimeout(eraseLines, 50);
    }
}


//create a "start" function that will call any functions that you need to load right away
//we will load the lines array right at the beginning so they are available for use.

function startScripts() {
	createLines(lines, ctx, 0);
}

window.onload = startScripts();




</script>




</body>
</html>
